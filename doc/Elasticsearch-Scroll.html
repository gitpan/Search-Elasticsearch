<html>
<head>
<title></title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" />
<link rel='stylesheet' href='https://metacpan.org/_asset/288683e3285b02987a848283f0f92207' type='text/css'>
<script type='text/javascript' src='https://metacpan.org/_asset/12b19d083bf773523c065d4d729f0327'></script>
</head>
<body>
<div class="pod">


<ul id="index">
  <li><a href="#SYNOPSIS">SYNOPSIS</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a></li>
  <li><a href="#USE-CASES">USE CASES</a>
    <ul>
      <li><a href="#Pulling-enough-results">Pulling enough results</a></li>
      <li><a href="#Extracting-all-documents">Extracting all documents</a></li>
    </ul>
  </li>
  <li><a href="#DEEP-SCROLLING">DEEP SCROLLING</a>
    <ul>
      <li><a href="#Disable-sorting-for-efficient-scrolling">Disable sorting for efficient scrolling</a></li>
    </ul>
  </li>
  <li><a href="#METHODS">METHODS</a>
    <ul>
      <li><a href="#new-"><code>new()</code></a></li>
      <li><a href="#next-"><code>next()</code></a></li>
      <li><a href="#drain_buffer-"><code>drain_buffer()</code></a></li>
      <li><a href="#refill_buffer-"><code>refill_buffer()</code></a></li>
      <li><a href="#buffer_size-"><code>buffer_size()</code></a></li>
      <li><a href="#eof-"><code>eof()</code></a></li>
      <li><a href="#finish-"><code>finish()</code></a></li>
    </ul>
  </li>
  <li><a href="#INFO-ACCESSORS">INFO ACCESSORS</a>
    <ul>
      <li><a href="#total"><code>total</code></a></li>
      <li><a href="#max_score"><code>max_score</code></a></li>
      <li><a href="#facets"><code>facets</code></a></li>
      <li><a href="#suggest"><code>suggest</code></a></li>
      <li><a href="#took"><code>took</code></a></li>
      <li><a href="#took_total"><code>took_total</code></a></li>
    </ul>
  </li>
  <li><a href="#SEE-ALSO">SEE ALSO</a></li>
</ul>

<h1 id="SYNOPSIS">SYNOPSIS</h1>

<pre class="brush: pl; class-name: 'highlight'; toolbar: false; gutter: false">    use Elasticsearch;
    use Elasticearch::Scroll;

    my $es     = Elasticsearch-&gt;new;

    my $scroll = ElasticSearch::Scroll-&gt;new(
        es          =&gt; $es,
        index       =&gt; &#39;my_index&#39;,
        search_type =&gt; &#39;scan&#39;,
        size        =&gt; 500
    );

    say &quot;Total hits: &quot;. $scroll-&gt;total;

    while (my $doc = $scroll-&gt;next) {
        # do something
    }</pre>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<p>A <i>scrolled search</i> is a search that allows you to keep pulling results until there are no more matching results, much like a cursor in an SQL database.</p>

<p>Unlike paginating through results (with the <code>from</code> parameter in <a href="./Elasticsearch::Client::Direct#search-">search()</a>), scrolled searches take a snapshot of the current state of the index. Even if you keep adding new documents to the index or updating existing documents, a scrolled search will only see the index as it was when the search began.</p>

<p>This module is a helper utility that wraps the functionality of the <a href="./Elasticsearch::Client::Direct#search-">search()</a> and <a href="./Elasticsearch::Client::Direct#scroll-">scroll()</a> methods to make them easier to use.</p>

<p><b>IMPORTANT</b>: Deep scrolling can be expensive. See <a href="#DEEP-SCROLLING">&quot;DEEP SCROLLING&quot;</a> for more.</p>

<h1 id="USE-CASES">USE CASES</h1>

<p>There are two primary use cases:</p>

<h2 id="Pulling-enough-results">Pulling enough results</h2>

<p>Perhaps you want to group your results by some field, and you don&#39;t know exactly how many results you will need in order to return 10 grouped results. With a scrolled search you can keep pulling more results until you have enough. For instance, you can search emails in a mailing list, and return results grouped by <code>thread_id</code>:</p>

<pre class="brush: pl; class-name: 'highlight'; toolbar: false; gutter: false">    my (%groups,@results);

    my $scroll = Elasticsearch::Scroll-&gt;new(
        es    =&gt; $es,
        index =&gt; &#39;my_emails&#39;,
        type  =&gt; &#39;email&#39;,
        body  =&gt; { query =&gt; {... some query ... }}
    );

    my $doc;
    while (@results &lt; 10 and $doc = $scroll-&gt;next) {

        my $thread = $doc-&gt;{_source}{thread_id};

        unless ($groups{$thread}) {
            $groups{$thread} = [];
            push @results, $groups{$thread};
        }
        push @{$groups{$thread}},$doc;

    }</pre>

<h2 id="Extracting-all-documents">Extracting all documents</h2>

<p>Often you will want to extract all (or a subset of) documents in an index. If you want to change your type mappings, you will need to reindex all of your data. Or perhaps you want to move a subset of the data in one index into a new dedicated index. In these cases, you don&#39;t care about sort order, you just want to retrieve all documents which match a query, and do something with them. For instance, to retrieve all the docs for a particular <code>client_id</code>:</p>

<pre class="brush: pl; class-name: 'highlight'; toolbar: false; gutter: false">    my $scroll = Elasticsearch::Scroll-&gt;new(
        es          =&gt; $es,
        index       =&gt; &#39;my_index&#39;,
        search_type =&gt; &#39;scan&#39;,          # important!
        size        =&gt; 500,
        body        =&gt; {
            query =&gt; {
                match =&gt; {
                    client_id =&gt; 123
                }
            }
        }
    );

    while my ( $doc = $scroll-&gt;next ) {
        # do something
    }</pre>

<p>Very often the <i>something</i> that you will want to do with these results involves bulk-indexing them into a new index. The easiest way to marry a scrolled search with bulk indexing is to use the <a href="./Elasticsearch::Bulk#reindex-">&quot;reindex()&quot; in Elasticsearch::Bulk</a> method.</p>

<h1 id="DEEP-SCROLLING">DEEP SCROLLING</h1>

<p>Deep scrolling (and deep pagination) are very expensive in a distributed environment, and the reason they are expensive is that results need to be sorted in a global order.</p>

<p>For example, if we have an index with 5 shards, and we request the first 10 results, each shard has to return its top 10, and then the <i>requesting node</i> (the node that is handling the search request) has to resort these 50 results to return a global top 10. Now, if we request page 1,000 (ie results 10,001 .. 10,010), then each shard has to return 10,010 results, and the requesting node has to sort through 50,050 results just to return 10 of them!</p>

<p>You can see how this can get very heavy very quickly. This is the reason that web search engines never return more than 1,000 results.</p>

<h2 id="Disable-sorting-for-efficient-scrolling">Disable sorting for efficient scrolling</h2>

<p>The problem with deep scrolling is the sorting phase. If we disable sorting, then we can happily scroll through millions of documents efficiently. The way to do this is to set <code>search_type</code> to <code>scan</code>:</p>

<pre class="brush: pl; class-name: 'highlight'; toolbar: false; gutter: false">    $scroll = Elasticsearch::Scroll-&gt;new(
        es          =&gt; $es,
        search_type =&gt; &#39;scan&#39;,
        size        =&gt; 500,
    );</pre>

<p>Scanning disables sorting and will just return <code>size</code> results from each shard until there are no more results to return. <b>Note</b>: this means that, when querying an index with 5 shards, the scrolled search will pull <code>size * 5</code> results at a time. If you have large documents or are memory constrained, you will need to take this into account.</p>

<h1 id="METHODS">METHODS</h1>

<h2 id="new-"><code>new()</code></h2>

<pre class="brush: pl; class-name: 'highlight'; toolbar: false; gutter: false">    use Elasticsearch;
    use Elasticsearch::Scroll;

    my $es = Elasticsearch-&gt;new(...);
    my $scroll = Elasticsearch::Scroll-&gt;new(
        es      =&gt; $es,                         # required
        scroll  =&gt; &#39;1m&#39;,                        # optional
        %search_params
    );</pre>

<p>The <code>new()</code> method returns a new <code>$scroll</code> object. You must pass your Elasticsearch client as the <code>es</code> argument, and you can specify a <code>scroll</code> duration (which defaults to <code>&quot;1m&quot;</code>). Any other parameters are passed directly to <a href="./Elasticsearch::Client::Direct#search-">&quot;search()&quot; in Elasticsearch::Client::Direct</a>.</p>

<p>The <code>scroll</code> duration tells Elasticearch how long it should keep the scroll alive. <b>Note</b>: this duration doesn&#39;t need to be long enough to process all results, just long enough to process a single <b>batch</b> of results. The expiry gets renewed for another <code>scroll</code> period every time new a new batch of results is retrieved from the cluster.</p>

<h2 id="next-"><code>next()</code></h2>

<pre class="brush: pl; class-name: 'highlight'; toolbar: false; gutter: false">    $doc  = $scroll-&gt;next;
    @docs = $scroll-&gt;next($num);</pre>

<p>The <code>next()</code> method returns the next result, or the next <code>$num</code> results (pulling more results if required). If all results have been exhausted, it returns an empty list.</p>

<h2 id="drain_buffer-"><code>drain_buffer()</code></h2>

<pre class="brush: pl; class-name: 'highlight'; toolbar: false; gutter: false">    @docs = $scroll-&gt;drain_buffer;</pre>

<p>The <code>drain_buffer()</code> method returns all of the documents currently in the buffer, without fetching any more from the cluster.</p>

<h2 id="refill_buffer-"><code>refill_buffer()</code></h2>

<pre class="brush: pl; class-name: 'highlight'; toolbar: false; gutter: false">    $total = $scroll-&gt;refill_buffer;</pre>

<p>The <code>refill_buffer()</code> method fetches the next batch of results from the cluster, stores them in the buffer, and returns the total number of docs currently in the buffer.</p>

<h2 id="buffer_size-"><code>buffer_size()</code></h2>

<pre class="brush: pl; class-name: 'highlight'; toolbar: false; gutter: false">    $total = $scroll-&gt;buffer_size;</pre>

<p>The <code>buffer_size()</code> method returns the total number of docs currently in the buffer.</p>

<h2 id="eof-"><code>eof()</code></h2>

<pre class="brush: pl; class-name: 'highlight'; toolbar: false; gutter: false">    $bool = $scroll-&gt;eof;</pre>

<p>The <code>eof()</code> method reports whether there may be more results to pull from the cluster or not. If it returns <code>false</code> it doesn&#39;t mean that there are definitely more results, just that we don&#39;t yet know. If it returns <code>true</code> then there are definitely no more results to be retrieved from the cluster, but there may still be results in local buffer.</p>

<h2 id="finish-"><code>finish()</code></h2>

<pre class="brush: pl; class-name: 'highlight'; toolbar: false; gutter: false">    $scroll-&gt;finish;</pre>

<p>The <code>finish()</code> method clears out the buffer, sets <a href="#eof-">&quot;eof()&quot;</a> to <code>true</code> and tries to clear the <code>scroll_id</code> on Elasticsearch. This API is only supported since v0.90.5, but the call to <code>clear_scroll</code> is wrapped in an <code>eval</code> so the <code>finish()</code> method can be safely called with any version of Elasticsearch.</p>

<p>When the <code>$scroll</code> instance goes out of scope, <a href="#finish-">&quot;finish()&quot;</a> is called automatically unless <a href="#eof-">&quot;eof()&quot;</a> returns <code>true</code>.</p>

<h1 id="INFO-ACCESSORS">INFO ACCESSORS</h1>

<p>The information from the original search is returned via the following accessors:</p>

<h2 id="total"><code>total</code></h2>

<p>The total number of documents that matched your query.</p>

<h2 id="max_score"><code>max_score</code></h2>

<p>The maximum score of any documents in your query.</p>

<h2 id="facets"><code>facets</code></h2>

<p>Any facets that were specified, or <code>undef</code></p>

<h2 id="suggest"><code>suggest</code></h2>

<p>Any suggestions that were specified, or <code>undef</code></p>

<h2 id="took"><code>took</code></h2>

<p>How long the original search took, in milliseconds</p>

<h2 id="took_total"><code>took_total</code></h2>

<p>How long the original search plus all subsequent batches took, in milliseconds.</p>

<h1 id="SEE-ALSO">SEE ALSO</h1>

<ul>

<li><p><a href="./Elasticsearch::Bulk#reindex-">&quot;reindex()&quot; in Elasticsearch::Bulk</a></p>

</li>
<li><p><a href="./Elasticsearch::Client::Direct#search-">&quot;search()&quot; in Elasticsearch::Client::Direct</a></p>

</li>
<li><p><a href="./Elasticsearch::Client::Direct#scroll-">&quot;scroll()&quot; in Elasticsearch::Client::Direct</a></p>

</li>
</ul>


</div>
</body>
</html>


